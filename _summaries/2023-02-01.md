# 2023-02-01

- mysql index dive
- hibernate.query.in_clause_parameter_padding=tru

# mysql index dive

 **`index dive(random index dive)`** 는 실행 계획을 선택하기 위해 사전에 데이터를 샘플링해서 확인하는 과정을 말한다. 
 MySQL 서버의 옵티마이저는 통계 정보와 index dive 한 내용을 토대로 실행계획을 수립한다. 
 Oracle 과 PostgreSQL 의 경우 실행 계획을 캐싱해 재활용 하지만 MySQL 서버는 실행 계획을 커넥션 내에서만 캐시되고 재활용하는 방법을 사용한다.

> 이와 같은 방법은 때로 의도하지 않은 CPU 와 Disk 자원을 소모하는 경우가 있어 이와 같은 경우를 염두해두고 튜닝하는 방법을 염두해두어야 한다.
  성능을 확인해보기 위해서는 [MySQL Performance schema](https://dev.mysql.com/doc/refman/8.0/en/performance-schema.html) 또는
  [AWS Performance Insights](https://aws.amazon.com/ko/rds/performance-insights/) 이다.
    
- `MySQL Performance schema` : MySQL 서버 실행을 모니터링하는 기능 
- `AWS Performance Insights` : AWS RDS 를 모니터링할 수 있는 새로운 기능

<br>

일반적으로 Performance Schema 또는 Performance Insights 에는 쿼리의 실행(executing) 자체에 많은 자원이 사용되야 때로는 통계 수집(statistics) 
단계에서 많은 자원이 소모되는 경우가 있다. **일반적으로 쿼리 실행 단계가 통계 수집 단계보다 많은 비중을 차지**하지만 `WHERE 절에 IN 을 처리할 때` 
**통계 수집 단계가 실행 단계의 비중을 역전**하는 상황이 벌어진다.

- 많은 개수의 엘리멘트가 IN (list)에 사용되는 경우 : `WHERE column_name IN (...)`
- IN (list) 조건 자체가 여러 번 사용되는 경우 : `WHERE column_name_1 IN (...) and column_name_2 IN (...)`
- IN (list) 조건들이 사용할 수 있는 인덱스가 많은 경우
    ``` mysql
    CREATE TABLE table_name (
      id BIGINT NOT NULL,
      column_name_1 VARCHAR NOT NULL,
      column_name_2 VARCHAR NOT NULL,
      ...
      PRIMARY KEY (id),
      INDEX ix_userid (column_name_1),
      INDEX ix_userid_categoryid (column_name_1, column_name_2),
      INDEX ix_userid_categoryid_fd1 (column_name_1, column_name_2, fd1),
      INDEX ix_userid_categoryid_fd2 (column_name_1, column_name_2, fd2),
      INDEX ix_userid_categoryid_fd3 (column_name_1, column_name_2, fd3)
    );
    ```

<br>

문제 쿼리 예시

```mysql
SELECT *
FROM table_name
WHERE column_name1 IN (1,2,3,4,5, ..., 200)
  AND column_name2 IN (1,2,3,4,5, ..., 200);
```

 이와 같은 쿼리의 경우, `IN (list)` 에 포함된 `모든 조합에 대한 통계 정보를 수집한다.` 이 경우에는 200 * 200 총 40,000 개의 일치하는 레코드를
예측하는 작업을 진행한다. 만약 해당 컬럼(column_name1, column_name2) 포함하는 사용 가능한 인덱스가 존재하면 인덱스 수만큼 같은 작업을 진행한다.
**그만큼 많은 CPU 와 Disk 자원을 소모**하게 되고 **이전에 언급한 쿼리 실행 단계가 통계 수집 단계의 비중을 역전하는 상황**이 벌어진다.

<br>



### References

- [[당근마켓 팀블로그] Index Dive 비용 최적화](https://medium.com/daangn/index-dive-%EB%B9%84%EC%9A%A9-%EC%B5%9C%EC%A0%81%ED%99%94-1a50478f7df8)

<br>

### ToDoList
- [ ] MySQL docs Performance schema 읽어보기
- [ ] 우형에 AWS Performance Insights 에 관한 글 한번 읽어볼 것
    - [[우형 기술블로그] Performance Insight 써도 돼요?](https://techblog.woowahan.com/2593/)
